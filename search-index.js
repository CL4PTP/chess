var N = null;var searchIndex = {};
searchIndex["arrayvec"]={"doc":"arrayvec provides the types `ArrayVec` and `ArrayString`:  array-backed vector and string types, which store their contents inline.","items":[[3,"ArrayString","arrayvec","A string with a fixed capacity.",N,N],[3,"CapacityError","","Error value indicating insufficient capacity",N,N],[3,"ArrayVec","","A vector with a fixed capacity.",N,N],[3,"IntoIter","","By-value iterator for `ArrayVec`.",N,N],[3,"Drain","","A draining iterator for `ArrayVec`.",N,N],[11,"new","","Create a new empty `ArrayString`.",0,[[],["arraystring"]]],[11,"from","","Create a new `ArrayString` from a `str`.",0,[[["str"]],["result",["capacityerror"]]]],[11,"from_byte_string","","Create a new `ArrayString` from a byte string literal.",0,[[["a"]],["result",["utf8error"]]]],[11,"capacity","","Return the capacity of the `ArrayString`.",0,[[["self"]],["usize"]]],[11,"is_full","","Return if the `ArrayString` is completely filled.",0,[[["self"]],["bool"]]],[11,"push","","Adds the given char to the end of the string.",0,[[["self"],["char"]]]],[11,"try_push","","Adds the given char to the end of the string.",0,[[["self"],["char"]],["result",["capacityerror"]]]],[11,"push_str","","Adds the given string slice to the end of the string.",0,[[["self"],["str"]]]],[11,"try_push_str","","Adds the given string slice to the end of the string.",0,[[["self"],["str"]],["result",["capacityerror"]]]],[11,"pop","","Removes the last character from the string and returns it.",0,[[["self"]],["option",["char"]]]],[11,"truncate","","Shortens this `ArrayString` to the specified length.",0,[[["self"],["usize"]]]],[11,"remove","","Removes a `char` from this `ArrayString` at a byte position and returns it.",0,[[["self"],["usize"]],["char"]]],[11,"clear","","Make the string empty.",0,[[["self"]]]],[11,"set_len","","Set the strings’s length.",0,[[["self"],["usize"]]]],[11,"as_str","","Return a string slice of the whole `ArrayString`.",0,[[["self"]],["str"]]],[11,"new","","Create a new `CapacityError` from `element`.",1,[[["t"]],["capacityerror"]]],[11,"element","","Extract the overflowing element",1,[[["self"]],["t"]]],[11,"simplify","","Convert into a `CapacityError` that does not carry an element.",1,[[["self"]],["capacityerror"]]],[8,"Array","","Trait for fixed size arrays.",N,N],[16,"Item","","The array’s element type",2,N],[8,"RangeArgument","","`RangeArgument` is implemented by Rust's built-in range types, produced by range syntax like `..`, `a..`, `..b` or `c..d`.",N,N],[11,"start","","Start index (inclusive)",3,[[["self"]],["option",["usize"]]]],[11,"end","","End index (exclusive)",3,[[["self"]],["option",["usize"]]]],[11,"new","","Create a new empty `ArrayVec`.",4,[[],["arrayvec"]]],[11,"len","","Return the number of elements in the `ArrayVec`.",4,[[["self"]],["usize"]]],[11,"capacity","","Return the capacity of the `ArrayVec`.",4,[[["self"]],["usize"]]],[11,"is_full","","Return if the `ArrayVec` is completely filled.",4,[[["self"]],["bool"]]],[11,"push","","Push `element` to the end of the vector.",4,N],[11,"try_push","","Push `element` to the end of the vector.",4,N],[11,"push_unchecked","","Push `element` to the end of the vector without checking the capacity.",4,N],[11,"insert","","Insert `element` at position `index`.",4,N],[11,"try_insert","","Insert `element` at position `index`.",4,N],[11,"pop","","Remove the last element in the vector and return it.",4,[[["self"]],["option"]]],[11,"swap_remove","","Remove the element at `index` and swap the last element into its place.",4,N],[11,"swap_pop","","Remove the element at `index` and swap the last element into its place.",4,[[["self"],["usize"]],["option"]]],[11,"remove","","Remove the element at `index` and shift down the following elements.",4,N],[11,"pop_at","","Remove the element at `index` and shift down the following elements.",4,[[["self"],["usize"]],["option"]]],[11,"truncate","","Shortens the vector, keeping the first `len` elements and dropping the rest.",4,[[["self"],["usize"]]]],[11,"clear","","Remove all elements in the vector.",4,[[["self"]]]],[11,"retain","","Retains only the elements specified by the predicate.",4,[[["self"],["f"]]]],[11,"set_len","","Set the vector’s length without dropping or moving out elements",4,[[["self"],["usize"]]]],[11,"drain","","Create a draining iterator that removes the specified range in the vector and yields the removed items from start to end. The element range is removed even if the iterator is not consumed until the end.",4,[[["self"],["r"]],["drain"]]],[11,"into_inner","","Return the inner fixed size array, if it is full to its capacity.",4,[[["self"]],["result"]]],[11,"dispose","","Dispose of `self` without the overwriting that is needed in Drop.",4,[[["self"]]]],[11,"as_slice","","Return a slice containing all elements of the vector.",4,N],[11,"as_mut_slice","","Return a mutable slice containing all elements of the vector.",4,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"into_iter","","",4,[[["self"]],["i"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"into_iter","","",5,[[["self"]],["i"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"into_iter","","",6,[[["self"]],["i"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"clone","","",0,[[["self"]],["arraystring"]]],[11,"clone_from","","",0,[[["self"],["self"]]]],[11,"clone","","",1,[[["self"]],["capacityerror"]]],[11,"clone","","",5,[[["self"]],["intoiter"]]],[11,"clone","","",4,[[["self"]],["self"]]],[11,"clone_from","","",4,[[["self"],["self"]]]],[11,"extend","","",4,[[["self"],["t"]]]],[11,"from","","",4,[[["a"]],["self"]]],[11,"drop","","",4,[[["self"]]]],[11,"drop","","",5,[[["self"]]]],[11,"drop","","",6,[[["self"]]]],[11,"next","","",5,[[["self"]],["option"]]],[11,"size_hint","","",5,N],[11,"next","","",6,[[["self"]],["option"]]],[11,"size_hint","","",6,N],[11,"as_ref","","",0,[[["self"]],["str"]]],[11,"as_ref","","",4,N],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["self"]],["bool"]]],[11,"le","","",0,[[["self"],["self"]],["bool"]]],[11,"gt","","",0,[[["self"],["self"]],["bool"]]],[11,"ge","","",0,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["str"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["str"]],["bool"]]],[11,"le","","",0,[[["self"],["str"]],["bool"]]],[11,"gt","","",0,[[["self"],["str"]],["bool"]]],[11,"ge","","",0,[[["self"],["str"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["capacityerror"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"le","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"gt","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"ge","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["arrayvec"]],["option",["ordering"]]]],[11,"lt","","",4,[[["self"],["self"]],["bool"]]],[11,"le","","",4,[[["self"],["self"]],["bool"]]],[11,"ge","","",4,[[["self"],["self"]],["bool"]]],[11,"gt","","",4,[[["self"],["self"]],["bool"]]],[11,"default","","Return an empty `ArrayString`",0,[[],["arraystring"]]],[11,"default","","Return an empty array",4,[[],["arrayvec"]]],[11,"as_mut","","",4,N],[11,"eq","","",0,[[["self"],["self"]],["bool"]]],[11,"eq","","",0,[[["self"],["str"]],["bool"]]],[11,"eq","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"ne","","",1,[[["self"],["capacityerror"]],["bool"]]],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"eq","","",4,N],[11,"next_back","","",5,[[["self"]],["option"]]],[11,"next_back","","",6,[[["self"]],["option"]]],[11,"into_iter","","",4,[[["self"]],["intoiter"]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"cmp","","",1,[[["self"],["capacityerror"]],["ordering"]]],[11,"cmp","","",4,[[["self"],["arrayvec"]],["ordering"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"write_char","","",0,[[["self"],["char"]],["result"]]],[11,"write_str","","",0,[[["self"],["str"]],["result"]]],[11,"deref","","",0,[[["self"]],["str"]]],[11,"deref","","",4,N],[11,"deref_mut","","",0,[[["self"]],["str"]]],[11,"deref_mut","","",4,N],[11,"from_iter","","",4,[[["t"]],["self"]]],[11,"borrow","","",0,[[["self"]],["str"]]],[11,"borrow","","",4,N],[11,"write","","",4,N],[11,"flush","","",4,[[["self"]],["result"]]],[11,"description","","",1,[[["self"]],["str"]]],[11,"borrow_mut","","",4,N],[11,"start","","Start index (inclusive)",3,[[["self"]],["option",["usize"]]]],[11,"end","","End index (exclusive)",3,[[["self"]],["option",["usize"]]]]],"paths":[[3,"ArrayString"],[3,"CapacityError"],[8,"Array"],[8,"RangeArgument"],[3,"ArrayVec"],[3,"IntoIter"],[3,"Drain"]]};
searchIndex["chess"]={"doc":"Rust Chess Library This is a chess move generation library for rust.  It is designed to be fast, so that it can be used in a chess engine or UI without performance issues.","items":[[3,"Board","chess","A representation of a chess board.  That's why you're here, right?",N,N],[3,"BitBoard","","A good old-fashioned bitboard You do have access to the actual value, but you are probably better off using the implemented operators to work with this object.",N,N],[12,"0","","",0,N],[3,"CacheTable","","Store a cache of entries, each with an associated hash.",N,N],[3,"ChessMove","","Represent a ChessMove in memory",N,N],[3,"Square","","Represent a square on the chess board",N,N],[3,"MoveGen","","An incremental move generator",N,N],[3,"Game","","For UI/UCI Servers, store a game object which allows you to determine draw by 3 fold repitition, draw offers, resignations, and moves.",N,N],[4,"BoardStatus","","What is the status of this game?",N,N],[13,"Ongoing","","",1,N],[13,"Stalemate","","",1,N],[13,"Checkmate","","",1,N],[4,"CastleRights","","What castle rights does a particular player have?",N,N],[13,"NoRights","","",2,N],[13,"KingSide","","",2,N],[13,"QueenSide","","",2,N],[13,"Both","","",2,N],[4,"Color","","Represent a color.",N,N],[13,"White","","",3,N],[13,"Black","","",3,N],[4,"File","","Describe a file (column) on a chess board",N,N],[13,"A","","",4,N],[13,"B","","",4,N],[13,"C","","",4,N],[13,"D","","",4,N],[13,"E","","",4,N],[13,"F","","",4,N],[13,"G","","",4,N],[13,"H","","",4,N],[4,"Piece","","Represent a chess piece as a very simple enum",N,N],[13,"Pawn","","",5,N],[13,"Knight","","",5,N],[13,"Bishop","","",5,N],[13,"Rook","","",5,N],[13,"Queen","","",5,N],[13,"King","","",5,N],[4,"Rank","","Describe a rank (row) on a chess board",N,N],[13,"First","","",6,N],[13,"Second","","",6,N],[13,"Third","","",6,N],[13,"Fourth","","",6,N],[13,"Fifth","","",6,N],[13,"Sixth","","",6,N],[13,"Seventh","","",6,N],[13,"Eighth","","",6,N],[4,"Action","","Contains all actions supported within the game",N,N],[13,"MakeMove","","",7,N],[13,"OfferDraw","","",7,N],[13,"AcceptDraw","","",7,N],[13,"DeclareDraw","","",7,N],[13,"Resign","","",7,N],[4,"GameResult","","What was the result of this game?",N,N],[13,"WhiteCheckmates","","",8,N],[13,"WhiteResigns","","",8,N],[13,"BlackCheckmates","","",8,N],[13,"BlackResigns","","",8,N],[13,"Stalemate","","",8,N],[13,"DrawAccepted","","",8,N],[13,"DrawDeclared","","",8,N],[5,"construct","","This is now a no-op.  It does not need to be called anymore.",N,[[]]],[5,"between","","Get a line between these two squares, not including the squares themselves.",N,[[["square"],["square"]],["bitboard"]]],[5,"get_adjacent_files","","Get a `BitBoard` that represents the squares on the 1 or 2 files next to this file.",N,[[["file"]],["bitboard"]]],[5,"get_bishop_moves","","Get the moves for a bishop on a particular square, given blockers blocking my movement.",N,[[["square"],["bitboard"]],["bitboard"]]],[5,"get_bishop_rays","","Get the rays for a bishop on a particular square.",N,[[["square"]],["bitboard"]]],[5,"get_file","","Get a `BitBoard` that represents all the squares on a particular file.",N,[[["file"]],["bitboard"]]],[5,"get_king_moves","","Get the king moves for a particular square.",N,[[["square"]],["bitboard"]]],[5,"get_knight_moves","","Get the knight moves for a particular square.",N,[[["square"]],["bitboard"]]],[5,"get_pawn_attacks","","Get the pawn capture move for a particular square, given the pawn's color and the potential victims",N,[[["square"],["color"],["bitboard"]],["bitboard"]]],[5,"get_pawn_moves","","Get all the pawn moves for a particular square, given the pawn's color and the potential blocking pieces and victims.",N,[[["square"],["color"],["bitboard"]],["bitboard"]]],[5,"get_pawn_quiets","","Get the quiet pawn moves (non-captures) for a particular square, given the pawn's color and the potential blocking pieces.",N,[[["square"],["color"],["bitboard"]],["bitboard"]]],[5,"get_rank","","Get a `BitBoard` that represents all the squares on a particular rank.",N,[[["rank"]],["bitboard"]]],[5,"get_rook_moves","","Get the moves for a rook on a particular square, given blockers blocking my movement.",N,[[["square"],["bitboard"]],["bitboard"]]],[5,"get_rook_rays","","Get the rays for a rook on a particular square.",N,[[["square"]],["bitboard"]]],[5,"line","","Get a line (extending to infinity, which in chess is 8 squares), given two squares. This line does extend past the squares.",N,[[["square"],["square"]],["bitboard"]]],[11,"from_fen","","Construct a board from a FEN string.",9,[[["string"]],["option",["board"]]]],[11,"enumerate_moves","","",9,N],[11,"status","","Is this game Ongoing, is it Stalemate, or is it Checkmate?",9,[[["self"]],["boardstatus"]]],[11,"combined","","Grab the \"combined\" `BitBoard`.  This is a `BitBoard` with every piece.",9,[[["self"]],["bitboard"]]],[11,"color_combined","","Grab the \"color combined\" `BitBoard`.  This is a `BitBoard` with every piece of a particular color.",9,[[["self"],["color"]],["bitboard"]]],[11,"king_square","","Give me the `Square` the `color` king is on.",9,[[["self"],["color"]],["square"]]],[11,"pieces","","Grab the \"pieces\" `BitBoard`.  This is a `BitBoard` with every piece of a particular type.",9,[[["self"],["piece"]],["bitboard"]]],[11,"castle_rights","","Grab the `CastleRights` for a particular side.",9,[[["self"],["color"]],["castlerights"]]],[11,"add_castle_rights","","Add castle rights for a particular side.  Note: this can create an invalid position.",9,[[["self"],["color"],["castlerights"]]]],[11,"remove_castle_rights","","Remove castle rights for a particular side.",9,[[["self"],["color"],["castlerights"]]]],[11,"side_to_move","","Who's turn is it?",9,[[["self"]],["color"]]],[11,"my_castle_rights","","Grab my `CastleRights`.",9,[[["self"]],["castlerights"]]],[11,"add_my_castle_rights","","Add to my `CastleRights`.  Note: This can make the position invalid.",9,[[["self"],["castlerights"]]]],[11,"remove_my_castle_rights","","Remove some of my `CastleRights`.",9,[[["self"],["castlerights"]]]],[11,"their_castle_rights","","My opponents `CastleRights`.",9,[[["self"]],["castlerights"]]],[11,"add_their_castle_rights","","Add to my opponents `CastleRights`. Note: This can make the position invalid.",9,[[["self"],["castlerights"]]]],[11,"remove_their_castle_rights","","Remove some of my opponents `CastleRights`.",9,[[["self"],["castlerights"]]]],[11,"set_piece","","For a chess UI: set a piece on a particular square.",9,[[["self"],["piece"],["color"],["square"]],["option",["board"]]]],[11,"clear_square","","For a chess UI: clear a particular square.",9,[[["self"],["square"]],["option",["board"]]]],[11,"null_move","","Switch the color of the player without actually making a move.  Returns None if the current player is in check.",9,[[["self"]],["option",["board"]]]],[11,"is_sane","","Does this board \"make sense\"? Do all the pieces make sense, do the bitboards combine correctly, etc? This is for sanity checking.",9,[[["self"]],["bool"]]],[11,"get_hash","","Get a hash of the board.",9,[[["self"]],["u64"]]],[11,"get_pawn_hash","","Get a pawn hash of the board (a hash that only changes on color change and pawn moves).",9,[[["self"]],["u64"]]],[11,"piece_on","","What piece is on a particular `Square`?  Is there even one?",9,[[["self"],["square"]],["option",["piece"]]]],[11,"color_on","","What color piece is on a particular square?",9,[[["self"],["square"]],["option",["color"]]]],[11,"en_passant","","Give me the en_passant square, if it exists.",9,[[["self"]],["option",["square"]]]],[11,"legal","","Is a particular move legal?  This function is very slow, but will work on unsanitized input.",9,[[["self"],["chessmove"]],["bool"]]],[11,"make_move_new","","Make a chess move onto a new board.",9,[[["self"],["chessmove"]],["board"]]],[11,"make_move","","Make a chess move onto an already allocated `Board`.",9,[[["self"],["chessmove"],["board"]]]],[11,"pinned","","Give me the `BitBoard` of my pinned pieces.",9,[[["self"]],["bitboard"]]],[11,"checkers","","Give me the `Bitboard` of the pieces putting me in check.",9,[[["self"]],["bitboard"]]],[11,"new","","Construct a new bitboard from a u64",0,[[["u64"]],["bitboard"]]],[11,"set","","Construct a new `BitBoard` with a particular `Square` set",0,[[["rank"],["file"]],["bitboard"]]],[11,"from_square","","Construct a new `BitBoard` with a particular `Square` set",0,[[["square"]],["bitboard"]]],[11,"from_maybe_square","","Convert an `Option<Square>` to an `Option<BitBoard>`",0,[[["option",["square"]]],["option",["bitboard"]]]],[11,"to_square","","Convert a `BitBoard` to a `Square`.  This grabs the least-significant `Square`",0,[[["self"]],["square"]]],[11,"popcnt","","Count the number of `Squares` set in this `BitBoard`",0,[[["self"]],["u32"]]],[11,"reverse_colors","","Reverse this `BitBoard`.  Look at it from the opponents perspective.",0,[[["self"]],["bitboard"]]],[11,"to_size","","Convert this `BitBoard` to a `usize` (for table lookups)",0,[[["self"],["u8"]],["usize"]]],[11,"new","","Create a new `CacheTable` with each associated entry initialized with a hash of '0' Note: You must pass in a size where only 1 bit is set. (AKA: 2, 4, 8, 16, 1024, 65536, etc.) Panics when size is invalid.",10,[[["usize"],["t"]],["cachetable"]]],[11,"get","","Get a particular entry with the hash specified",10,[[["self"],["u64"]],["option"]]],[11,"add","","Add (or overwrite) an entry with the associated hash",10,[[["self"],["u64"],["t"]]]],[11,"has_kingside","","Can I castle kingside?",2,[[["self"]],["bool"]]],[11,"has_queenside","","Can I castle queenside?",2,[[["self"]],["bool"]]],[11,"square_to_castle_rights","","",2,[[["color"],["square"]],["castlerights"]]],[11,"kingside_squares","","What squares need to be empty to castle kingside?",2,[[["self"],["color"]],["bitboard"]]],[11,"queenside_squares","","What squares need to be empty to castle queenside?",2,[[["self"],["color"]],["bitboard"]]],[11,"remove","","Remove castle rights, and return a new `CastleRights`.",2,[[["self"],["castlerights"]],["castlerights"]]],[11,"add","","Add some castle rights, and return a new `CastleRights`.",2,[[["self"],["castlerights"]],["castlerights"]]],[11,"to_index","","Convert `CastleRights` to `usize` for table lookups",2,[[["self"]],["usize"]]],[11,"from_index","","Convert `usize` to `CastleRights`.  Panic if invalid number.",2,[[["usize"]],["castlerights"]]],[11,"unmoved_rooks","","Which rooks can we \"guarantee\" we haven't moved yet?",2,[[["self"],["color"]],["bitboard"]]],[11,"rook_square_to_castle_rights","","Given a square of a rook, which side is it on? Note: It is invalid to pass in a non-rook square.  The code may panic.",2,[[["square"]],["castlerights"]]],[11,"new","","Create a new chess move, given a source `Square`, a destination `Square`, and an optional promotion `Piece`",11,[[["square"],["square"],["option",["piece"]]],["chessmove"]]],[11,"get_source","","Get the source square (square the piece is currently on).",11,[[["self"]],["square"]]],[11,"get_dest","","Get the destination square (square the piece is going to).",11,[[["self"]],["square"]]],[11,"get_promotion","","Get the promotion piece (maybe).",11,[[["self"]],["option",["piece"]]]],[11,"to_index","","Convert the `Color` to a `usize` for table lookups.",3,[[["self"]],["usize"]]],[11,"to_my_backrank","","Covert the `Color` to a rank, which reperesnts the starting position for that colors pieces.",3,[[["self"]],["rank"]]],[11,"to_their_backrank","","Convert a `Color` to my opponents backrank, which represents the starting position for the opponents pieces.",3,[[["self"]],["rank"]]],[11,"to_second_rank","","Convert a `Color` to my second rank, which represents the starting position for my pawns.",3,[[["self"]],["rank"]]],[11,"to_fourth_rank","","",3,[[["self"]],["rank"]]],[11,"to_seventh_rank","","Convert a `Color` to my seventh rank, which represents the rank before pawn promotion.",3,[[["self"]],["rank"]]],[11,"from_index","","Convert a `usize` into a `File` (the inverse of to_index).  If i > 7, wrap around.",4,[[["usize"]],["file"]]],[11,"left","","Go one file to the left.  If impossible, wrap around.",4,[[["self"]],["file"]]],[11,"right","","Go one file to the right.  If impossible, wrap around.",4,[[["self"]],["file"]]],[11,"to_index","","Convert this `File` into a `usize` from 0 to 7 inclusive.",4,[[["self"]],["usize"]]],[11,"to_index","","Convert the `Piece` to a `usize` for table lookups.",5,[[["self"]],["usize"]]],[11,"from_index","","Convert a `usize` into a `Rank` (the inverse of to_index).  If the number is > 7, wrap around.",6,[[["usize"]],["rank"]]],[11,"down","","Go one rank down.  If impossible, wrap around.",6,[[["self"]],["rank"]]],[11,"up","","Go one file up.  If impossible, wrap around.",6,[[["self"]],["rank"]]],[11,"to_index","","Convert this `Rank` into a `usize` between 0 and 7 (inclusive).",6,[[["self"]],["usize"]]],[11,"new","","Create a new square, given an index. Note: It is invalid, but allowed, to pass in a number >= 64.  Doing so will crash stuff.",12,[[["u8"]],["square"]]],[11,"make_square","","Make a square given a rank and a file",12,[[["rank"],["file"]],["square"]]],[11,"get_rank","","Return the rank given this square.",12,[[["self"]],["rank"]]],[11,"get_file","","Return the file given this square.",12,[[["self"]],["file"]]],[11,"up","","If there is a square above me, return that.  Otherwise, None.",12,[[["self"]],["option",["square"]]]],[11,"down","","If there is a square below me, return that.  Otherwise, None.",12,[[["self"]],["option",["square"]]]],[11,"left","","If there is a square to the left of me, return that.  Otherwise, None.",12,[[["self"]],["option",["square"]]]],[11,"right","","If there is a square to the right of me, return that.  Otherwise, None.",12,[[["self"]],["option",["square"]]]],[11,"forward","","If there is a square \"forward\", given my `Color`, go in that direction.  Otherwise, None.",12,[[["self"],["color"]],["option",["square"]]]],[11,"backward","","If there is a square \"backward\" given my `Color`, go in that direction.  Otherwise, None.",12,[[["self"],["color"]],["option",["square"]]]],[11,"uup","","If there is a square above me, return that.  If not, wrap around to the other side.",12,[[["self"]],["square"]]],[11,"udown","","If there is a square below me, return that.  If not, wrap around to the other side.",12,[[["self"]],["square"]]],[11,"uleft","","If there is a square to the left of me, return that. If not, wrap around to the other side.",12,[[["self"]],["square"]]],[11,"uright","","If there is a square to the right of me, return that.  If not, wrap around to the other side.",12,[[["self"]],["square"]]],[11,"uforward","","If there is a square \"forward\", given my color, return that.  If not, wrap around to the other side.",12,[[["self"],["color"]],["square"]]],[11,"ubackward","","If there is a square \"backward\", given my color, return that.  If not, wrap around to the other side.",12,[[["self"],["color"]],["square"]]],[11,"to_int","","Convert this square to an integer.",12,[[["self"]],["u8"]]],[11,"to_index","","Convert this `Square` to a `usize` for table lookup purposes",12,[[["self"]],["usize"]]],[11,"from_string","","Convert a UCI `String` to a square.  If invalid, return `None`",12,[[["string"]],["option",["square"]]]],[11,"new_legal","","Create a new `MoveGen` structure, only generating legal moves",13,[[["board"]],["movegen"]]],[11,"remove_mask","","Never, ever, iterate any moves that land on the following squares",13,[[["self"],["bitboard"]]]],[11,"remove_move","","Never, ever, iterate this move",13,[[["self"],["chessmove"]],["bool"]]],[11,"set_iterator_mask","","For now, Only iterate moves that land on the following squares Note: Once iteration is completed, you can pass in a mask of ! `EMPTY`       to get the remaining moves, or another mask",13,[[["self"],["bitboard"]]]],[11,"legal_quick","","This function checks the legality only for moves generated by `MoveGen`.",13,[[["board"],["chessmove"]],["bool"]]],[11,"movegen_perft_test","","Fastest perft test with this structure",13,[[["board"],["usize"]],["usize"]]],[11,"new","","Create a new `Game` with the initial position.",14,[[],["game"]]],[11,"actions","","Get all actions made in this game (moves, draw offers, resignations, etc.)",14,[[["self"]],["vec"]]],[11,"result","","What is the status of this game?",14,[[["self"]],["option",["gameresult"]]]],[11,"new_from_fen","","Create a new `Game` object from an FEN string.",14,[[["str"]],["option",["game"]]]],[11,"current_position","","Get the current position on the board from the `Game` object.",14,[[["self"]],["board"]]],[11,"can_declare_draw","","Determine if a player can legally declare a draw by 3-fold repetition or 50-move rule.",14,[[["self"]],["bool"]]],[11,"declare_draw","","Declare a draw by 3-fold repitition or 50-move rule.",14,[[["self"]],["bool"]]],[11,"make_move","","Make a chess move on the board",14,[[["self"],["chessmove"]],["bool"]]],[11,"side_to_move","","Who's turn is it to move?",14,[[["self"]],["color"]]],[11,"offer_draw","","Offer a draw to my opponent.  `color` is the player who offered the draw.  The draw must be accepted before my opponent moves.",14,[[["self"],["color"]],["bool"]]],[11,"accept_draw","","Accept a draw offer from my opponent.",14,[[["self"]],["bool"]]],[11,"resign","","`color` resigns the game",14,[[["self"],["color"]],["bool"]]],[17,"EMPTY","","An empty bitboard.  It is sometimes useful to use !EMPTY to get the universe of squares.",N,N],[17,"NUM_CASTLE_RIGHTS","","How many different types of `CastleRights` are there?",N,N],[17,"ALL_CASTLE_RIGHTS","","Enumerate all castle rights.",N,N],[17,"NUM_COLORS","","How many colors are there?",N,N],[17,"ALL_COLORS","","List all colors",N,N],[17,"NUM_FILES","","How many files are there?",N,N],[17,"ALL_FILES","","Enumerate all files",N,N],[17,"EDGES","","What are all the edge squares on the `BitBoard`?",N,N],[17,"NUM_PIECES","","How many piece types are there?",N,N],[17,"ALL_PIECES","","An array representing each piece type, in order of ascending value.",N,N],[17,"NUM_PROMOTION_PIECES","","How many ways can I promote?",N,N],[17,"PROMOTION_PIECES","","What pieces can I promote to?",N,N],[17,"NUM_RANKS","","How many ranks are there?",N,N],[17,"ALL_RANKS","","Enumerate all ranks",N,N],[17,"NUM_SQUARES","","How many squares are there?",N,N],[17,"ALL_SQUARES","","A list of every square on the chessboard.",N,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"into_iter","","",0,[[["self"]],["i"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"into_iter","","",13,[[["self"]],["i"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"clone","","",9,[[["self"]],["board"]]],[11,"clone","","",1,[[["self"]],["boardstatus"]]],[11,"clone","","",0,[[["self"]],["bitboard"]]],[11,"clone","","",2,[[["self"]],["castlerights"]]],[11,"clone","","",11,[[["self"]],["chessmove"]]],[11,"clone","","",3,[[["self"]],["color"]]],[11,"clone","","",4,[[["self"]],["file"]]],[11,"clone","","",5,[[["self"]],["piece"]]],[11,"clone","","",6,[[["self"]],["rank"]]],[11,"clone","","",12,[[["self"]],["square"]]],[11,"clone","","",7,[[["self"]],["action"]]],[11,"clone","","",8,[[["self"]],["gameresult"]]],[11,"clone","","",14,[[["self"]],["game"]]],[11,"next","","",0,[[["self"]],["option",["square"]]]],[11,"size_hint","","Give a size_hint to some functions that need it",13,N],[11,"next","","Find the next chess move.",13,[[["self"]],["option",["chessmove"]]]],[11,"len","","Give the exact length of this iterator",13,[[["self"]],["usize"]]],[11,"partial_cmp","","",1,[[["self"],["boardstatus"]],["option",["ordering"]]]],[11,"partial_cmp","","",0,[[["self"],["bitboard"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"le","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"gt","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"ge","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["castlerights"]],["option",["ordering"]]]],[11,"partial_cmp","","",11,[[["self"],["chessmove"]],["option",["ordering"]]]],[11,"lt","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"le","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"gt","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"ge","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"partial_cmp","","",3,[[["self"],["color"]],["option",["ordering"]]]],[11,"partial_cmp","","",4,[[["self"],["file"]],["option",["ordering"]]]],[11,"partial_cmp","","",5,[[["self"],["piece"]],["option",["ordering"]]]],[11,"partial_cmp","","",6,[[["self"],["rank"]],["option",["ordering"]]]],[11,"partial_cmp","","",12,[[["self"],["square"]],["option",["ordering"]]]],[11,"lt","","",12,[[["self"],["square"]],["bool"]]],[11,"le","","",12,[[["self"],["square"]],["bool"]]],[11,"gt","","",12,[[["self"],["square"]],["bool"]]],[11,"ge","","",12,[[["self"],["square"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["action"]],["option",["ordering"]]]],[11,"lt","","",7,[[["self"],["action"]],["bool"]]],[11,"le","","",7,[[["self"],["action"]],["bool"]]],[11,"gt","","",7,[[["self"],["action"]],["bool"]]],[11,"ge","","",7,[[["self"],["action"]],["bool"]]],[11,"partial_cmp","","",8,[[["self"],["gameresult"]],["option",["ordering"]]]],[11,"default","","",9,[[],["board"]]],[11,"default","","",0,[[],["bitboard"]]],[11,"default","","",11,[[],["chessmove"]]],[11,"default","","Create a square on A1.",12,[[],["square"]]],[11,"eq","","",9,[[["self"],["board"]],["bool"]]],[11,"ne","","",9,[[["self"],["board"]],["bool"]]],[11,"eq","","",1,[[["self"],["boardstatus"]],["bool"]]],[11,"eq","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"ne","","",0,[[["self"],["bitboard"]],["bool"]]],[11,"eq","","",2,[[["self"],["castlerights"]],["bool"]]],[11,"eq","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"ne","","",11,[[["self"],["chessmove"]],["bool"]]],[11,"eq","","",3,[[["self"],["color"]],["bool"]]],[11,"eq","","",4,[[["self"],["file"]],["bool"]]],[11,"eq","","",5,[[["self"],["piece"]],["bool"]]],[11,"eq","","",6,[[["self"],["rank"]],["bool"]]],[11,"eq","","",12,[[["self"],["square"]],["bool"]]],[11,"ne","","",12,[[["self"],["square"]],["bool"]]],[11,"eq","","",7,[[["self"],["action"]],["bool"]]],[11,"ne","","",7,[[["self"],["action"]],["bool"]]],[11,"eq","","",8,[[["self"],["gameresult"]],["bool"]]],[11,"cmp","","",11,[[["self"],["chessmove"]],["ordering"]]],[11,"cmp","","",5,[[["self"],["piece"]],["ordering"]]],[11,"cmp","","",12,[[["self"],["square"]],["ordering"]]],[11,"cmp","","",8,[[["self"],["gameresult"]],["ordering"]]],[11,"hash","","",2,N],[11,"hash","","",11,N],[11,"hash","","",3,N],[11,"hash","","",4,N],[11,"hash","","",5,N],[11,"hash","","",6,N],[11,"hash","","",12,N],[11,"hash","","",8,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"mul","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"mul","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"not","","",0,[[["self"]],["bitboard"]]],[11,"not","","Get the other color.",3,[[["self"]],["color"]]],[11,"bitand","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitand","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitor","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitor","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitxor","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitxor","","",0,[[["self"],["bitboard"]],["bitboard"]]],[11,"bitand_assign","","",0,[[["self"],["bitboard"]]]],[11,"bitand_assign","","",0,[[["self"],["bitboard"]]]],[11,"bitor_assign","","",0,[[["self"],["bitboard"]]]],[11,"bitor_assign","","",0,[[["self"],["bitboard"]]]],[11,"bitxor_assign","","",0,[[["self"],["bitboard"]]]],[11,"bitxor_assign","","",0,[[["self"],["bitboard"]]]]],"paths":[[3,"BitBoard"],[4,"BoardStatus"],[4,"CastleRights"],[4,"Color"],[4,"File"],[4,"Piece"],[4,"Rank"],[4,"Action"],[4,"GameResult"],[3,"Board"],[3,"CacheTable"],[3,"ChessMove"],[3,"Square"],[3,"MoveGen"],[3,"Game"]]};
searchIndex["nodrop"]={"doc":"The nodrop crate has the following cargo feature flags:","items":[[3,"NoDrop","nodrop","A type holding T that will not call its destructor on drop",N,N],[11,"new","","Create a new NoDrop.",0,[[["t"]],["nodrop"]]],[11,"into_inner","","Extract the inner value.",0,[[["self"]],["t"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"drop","","",0,[[["self"]]]],[11,"deref","","",0,[[["self"]],["t"]]],[11,"deref_mut","","",0,[[["self"]],["t"]]]],"paths":[[3,"NoDrop"]]};
initSearch(searchIndex);
